{"Key":{"Uuid":"74ca45ff-92c9-44a0-8f1a-754dea05ee1b","Effect":""},"Name":"RGB Perlin Noise","Preset":{"Fragment":"/*{\n    \"CATEGORIES\": [\n        \"Noise\",\n        \"Utility\"\n    ],\n    \"CREDIT\": \"Tuxic\",\n    \"DESCRIPTION\": \"generates a basic perlin noise\",\n    \"INPUTS\": [\n        {\n            \"DEFAULT\": 12.9898,\n            \"MAX\": 100,\n            \"MIN\": 0,\n            \"NAME\": \"seed\",\n            \"TYPE\": \"float\"\n        },\n        {\n            \"DEFAULT\": 4,\n            \"MAX\": 100,\n            \"MIN\": 0,\n            \"NAME\": \"scale\",\n            \"TYPE\": \"float\"\n        }\n    ],\n    \"ISFVSN\": \"2\"\n}\n*/\n\n// Author: Rich Harris\n// License: MIT\n\n// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nfloat random(vec2 co)\n{\n    highp float a = seed;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\n\n#define NUM_NOISE_OCTAVES 5\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 x) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid main()\n{\n    vec2 uv = isf_FragNormCoord.xy;\n    gl_FragColor = vec4(fbm(uv * scale), fbm(uv * scale -  vec2(1)), fbm(uv * scale + vec2(1)), 1.0);\n}\n","Vertex":"","Controls":[[0,{"Float":12.989800453186035}],[1,{"Float":4.0}]]}}