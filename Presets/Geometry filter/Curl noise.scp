{"Key":{"Uuid":"27d3cc85-a4b0-4924-8fde-71c337b40f59","Effect":""},"Name":"Curl noise","Preset":{"Shader":"/*{\n\"CREDIT\": \"Dihara Wijetunga, Ashima Arts, Keijiro Takahashi\",\n\"ISFVSN\": \"2\",\n\"DESCRIPTION\": \"Curl noise as implemented by https://github.com/diharaw/gpu-particle-system\",\n\"MODE\": \"GEOMETRY_FILTER\",\n\"CATEGORIES\": [ \"Geometry Effect\", \"Utility\" ],\n\"INPUTS\": [\n  {\n    \"NAME\": \"intensity\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 1.,\n    \"MIN\": 0.,\n    \"MAX\": 1.0\n  }, \n  {\n    \"NAME\": \"scale\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 1.,\n    \"MIN\": 0.,\n    \"MAX\": 1.0\n  }\n]\n}*/\n\n//\n// Noise Shader Library for Unity - https://github.com/keijiro/NoiseShader\n//\n// Original work (webgl-noise) Copyright (C) 2011 Ashima Arts.\n// Translation and modification was made by Keijiro Takahashi.\n//\n// This shader is based on the webgl-noise GLSL shader. For further details\n// of the original shader, please see the following description from the\n// original source code.\n//\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\n#define EPSILON 1e-3\n#define PI 3.1415926535\n\nvec3 mod289(vec3 x)\n{\n    return x - floor(x / 289.0) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x / 289.0) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289((x * 34.0 + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - r * 0.85373472095314;\n}\n\nfloat snoise(vec3 v)\n{\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    // Other corners\n    vec3 g  = step(x0.yzx, x0.xyz);\n    vec3 l  = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    // x1 = x0 - i1  + 1.0 * C.xxx;\n    // x2 = x0 - i2  + 2.0 * C.xxx;\n    // x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - 0.5;\n\n    // Permutations\n    i      = mod289(i); // Avoid truncation effects in permutation\n    vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                             + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    vec4 j = p - 49.0 * floor(p / 49.0); // mod(p,7*7)\n\n    vec4 x_ = floor(j / 7.0);\n    vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\n\n    vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;\n    vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;\n\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    //vec4 s0 = vec4(lessThan(b0, 0.0)) * 2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1, 0.0)) * 2.0 - 1.0;\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 g0 = vec3(a0.xy, h.x);\n    vec3 g1 = vec3(a0.zw, h.y);\n    vec3 g2 = vec3(a1.xy, h.z);\n    vec3 g3 = vec3(a1.zw, h.w);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(g0, g0), dot(g1, g1), dot(g2, g2), dot(g3, g3)));\n    g0 *= norm.x;\n    g1 *= norm.y;\n    g2 *= norm.z;\n    g3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m      = m * m;\n    m      = m * m;\n\n    vec4 px = vec4(dot(x0, g0), dot(x1, g1), dot(x2, g2), dot(x3, g3));\n    return 42.0 * dot(m, px);\n}\n\n\nvec3 curl_noise(vec3 coord)\n{\n    vec3 dx = vec3(EPSILON, 0.0, 0.0);\n    vec3 dy = vec3(0.0, EPSILON, 0.0);\n    vec3 dz = vec3(0.0, 0.0, EPSILON);\n\n    vec3 dpdx0 = vec3(snoise(coord - dx));\n    vec3 dpdx1 = vec3(snoise(coord + dx));\n    vec3 dpdy0 = vec3(snoise(coord - dy));\n    vec3 dpdy1 = vec3(snoise(coord + dy));\n    vec3 dpdz0 = vec3(snoise(coord - dz));\n    vec3 dpdz1 = vec3(snoise(coord + dz));\n\n    float x = dpdy1.z - dpdy0.z + dpdz1.y - dpdz0.y;\n    float y = dpdz1.x - dpdz0.x + dpdx1.z - dpdx0.z;\n    float z = dpdx1.y - dpdx0.y + dpdy1.x - dpdy0.x;\n\n    return vec3(x, y, z) / EPSILON * 2.0;\n}\n\nvoid process_vertex(inout vec3 position, inout vec3 normal, inout vec2 uv, inout vec3 tangent, inout vec4 color)\n{\n  float modifier = this_filter.intensity * this_filter.intensity * this_filter.intensity * this_filter.intensity * this_filter.intensity;\n  float tm = this_filter.scale * this_filter.scale * this_filter.scale * this_filter.scale * this_filter.scale * TIME;\n  position.xyz = mix(position.xyz, position.xyz + curl_noise(vec3(position.x * tm, position.y * tm, position.z * tm)), modifier);\n}\n","Controls":[[1,{"Float":1.0}],[2,{"Float":0.16184374690055847}]]}}
